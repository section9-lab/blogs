const e=JSON.parse('{"key":"v-6e700492","path":"/posts/guide/KafkaConf.html","title":"KafkaConf","lang":"zh-CN","frontmatter":{"icon":"fab fa-markdown","date":"2022-01-12T00:00:00.000Z","category":["Middleware"],"tag":["tools"],"star":true,"sticky":true,"description":"KafkaConf config public class ReliableProducer { public static void main(String[] args) { // Kafka broker 地址 String bootstrapServers = \\"localhost:9092\\"; // 设置 Producer 的配置信息 Properties props = new Properties(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); // 设置消息可靠性配置参数 props.put(ProducerConfig.ACKS_CONFIG, \\"all\\"); // 0不会等待任何broker的响应;1得到leader的确认;all等待所有副本写入确认 props.put(ProducerConfig.RETRIES_CONFIG, 3); // 自动重试 3 次 props.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, 1);//该参数指定了生产者在收到服务器晌应之前可以发送多少个消息。 // 开启幂等性,由于消息是分batch(批次)发送的，每个batch(批次)都有一个序列号。 //在Broker端，会追踪每个分区的最大序列号。如果出现序列号较小或相等的batch(批次)，broker将不会将该batch(批次)写入topic。 //这样，除了保证了幂等性，还可以确保batch(批次)的顺序。 props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true); props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, \\"snappy\\"); // 设置消息序列化：使用 StringSerializer 将键和值序列化为字节数组 props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); // 创建一个 KafkaProducer 实例，并指定 key 和 value 的类型为 String KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); // 创建一个消息 String topic = \\"test-topic\\"; String key = \\"key\\"; String value = \\"value\\"; // 发送消息，并阻塞直到发送完成 producer.send(new ProducerRecord&lt;&gt;(topic, key, value)).get(); // 关闭 producer producer.close(); } }","head":[["meta",{"property":"og:url","content":"https://section9-lab.github.io/blogs/blogs/posts/guide/KafkaConf.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"KafkaConf"}],["meta",{"property":"og:description","content":"KafkaConf config public class ReliableProducer { public static void main(String[] args) { // Kafka broker 地址 String bootstrapServers = \\"localhost:9092\\"; // 设置 Producer 的配置信息 Properties props = new Properties(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); // 设置消息可靠性配置参数 props.put(ProducerConfig.ACKS_CONFIG, \\"all\\"); // 0不会等待任何broker的响应;1得到leader的确认;all等待所有副本写入确认 props.put(ProducerConfig.RETRIES_CONFIG, 3); // 自动重试 3 次 props.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, 1);//该参数指定了生产者在收到服务器晌应之前可以发送多少个消息。 // 开启幂等性,由于消息是分batch(批次)发送的，每个batch(批次)都有一个序列号。 //在Broker端，会追踪每个分区的最大序列号。如果出现序列号较小或相等的batch(批次)，broker将不会将该batch(批次)写入topic。 //这样，除了保证了幂等性，还可以确保batch(批次)的顺序。 props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true); props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, \\"snappy\\"); // 设置消息序列化：使用 StringSerializer 将键和值序列化为字节数组 props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); // 创建一个 KafkaProducer 实例，并指定 key 和 value 的类型为 String KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); // 创建一个消息 String topic = \\"test-topic\\"; String key = \\"key\\"; String value = \\"value\\"; // 发送消息，并阻塞直到发送完成 producer.send(new ProducerRecord&lt;&gt;(topic, key, value)).get(); // 关闭 producer producer.close(); } }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-29T09:34:43.000Z"}],["meta",{"property":"article:author","content":"Section9lab"}],["meta",{"property":"article:tag","content":"tools"}],["meta",{"property":"article:published_time","content":"2022-01-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-29T09:34:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"KafkaConf\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-12T00:00:00.000Z\\",\\"dateModified\\":\\"2023-08-29T09:34:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Section9lab\\",\\"url\\":\\"https://section9-lab.github.io/blogs/\\"}]}"]]},"headers":[{"level":2,"title":"config","slug":"config","link":"#config","children":[]}],"git":{"createdTime":1693301683000,"updatedTime":1693301683000,"contributors":[{"name":"Tachikoma","email":"section9lab@gmail.com","commits":1}]},"readingTime":{"minutes":1.18,"words":355},"filePathRelative":"posts/guide/KafkaConf.md","localizedDate":"2022年1月12日","excerpt":"<h1> KafkaConf</h1>\\n\\n<hr>\\n<h2> config</h2>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>public class ReliableProducer {\\n\\n   public static void main(String[] args) {\\n\\n      // Kafka broker 地址\\n      String bootstrapServers = \\"localhost:9092\\";\\n\\n      // 设置 Producer 的配置信息\\n      Properties props = new Properties();\\n      props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\\n\\n      // 设置消息可靠性配置参数\\n      props.put(ProducerConfig.ACKS_CONFIG, \\"all\\"); // 0不会等待任何broker的响应;1得到leader的确认;all等待所有副本写入确认\\n      props.put(ProducerConfig.RETRIES_CONFIG, 3); // 自动重试 3 次\\n      props.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, 1);//该参数指定了生产者在收到服务器晌应之前可以发送多少个消息。\\n      // 开启幂等性,由于消息是分batch(批次)发送的，每个batch(批次)都有一个序列号。\\n      //在Broker端，会追踪每个分区的最大序列号。如果出现序列号较小或相等的batch(批次)，broker将不会将该batch(批次)写入topic。\\n      //这样，除了保证了幂等性，还可以确保batch(批次)的顺序。\\n      props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\\n\\n      props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, \\"snappy\\");\\n      // 设置消息序列化：使用 StringSerializer 将键和值序列化为字节数组\\n      props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\\n      props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\\n\\n      // 创建一个 KafkaProducer 实例，并指定 key 和 value 的类型为 String\\n      KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);\\n\\n      // 创建一个消息\\n      String topic = \\"test-topic\\";\\n      String key = \\"key\\";\\n      String value = \\"value\\";\\n\\n      // 发送消息，并阻塞直到发送完成\\n      producer.send(new ProducerRecord&lt;&gt;(topic, key, value)).get();\\n\\n      // 关闭 producer\\n      producer.close();\\n\\n   }\\n}\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
